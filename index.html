<!DOCTYPE html>
<html>
<head>
    <title> Experimental GLSL Signed Distance Function Demo </title>
    <script src = "scripts/jquery-1.11.0.min.js"></script>
    <script src = "scripts/require.js"></script>
    <link rel = "stylesheet" href = "main.css" />
    <!--script src="fun.js"></script-->
</head>

<body>
<h2>Processed Image</h2>
<p>
    Click in lower image to move seed point.

    Dragging left/right adjusts number of iterations (segmentation size).
</p>
<canvas id = "renderCanvas"></canvas>
<table id = "parameters">
    <tr>
        <th style="text-align:left">Number of Iterations</th>
    </tr><tr>
    <td><input type = "range" min = "1" max = "3000" value = "300" step = "2" id = "numberOfIterations"></td>
</tr><tr>
    <th style="text-align:left">Edge Weight</th>
</tr><tr>
    <td><input type = "range" min = "0" max = "200" value = "10" step = "1" id = "edgeWeight"></td>
</tr>
</table>

<p id = "log">Log output...<p>

<h2>Source Image</h2>

<!-- <img id="sourceImage" class='drawable' src="./coronal-mr-tumor.png" ></img> -->
<img id = "sourceImage" class = "drawable" src = "res/lung-lesion512.png" />

<!--script id="vertexShader" type="x-shader/x-vertex">
precision highp float;

attribute vec3 coordinate;
attribute vec2 textureCoordinate;

varying vec2 varyingTextureCoordinate;

void main(void) {
  gl_Position = vec4(coordinate,1.);
  varyingTextureCoordinate = textureCoordinate;
}
</script-->

<!--script id="fragmentShader" type="x-shader/x-fragment">
precision highp float;

// PDE filter.
//
// phi is updated as a function of its gradient and the image gradient


uniform sampler2D sourceTextureSampler;
uniform sampler2D intermediateTextureSampler;
uniform vec2 sourceTextureSize;
uniform vec2 sourceTexelSize;
uniform vec2 seedPoint;
uniform int iteration;
uniform int numberOfIterations;
uniform float edgeWeight;

varying vec2 varyingTextureCoordinate;

vec4 pack_float(const in float value)
{
    const vec4 bit_shift = vec4(256.0*256.0*256.0, 256.0*256.0, 256.0, 1.0);
    const vec4 bit_mask  = vec4(0.0, 1.0/256.0, 1.0/256.0, 1.0/256.0);
    vec4 res = fract(value * bit_shift);
    res -= res.xxyz * bit_mask;
    return res;
}

float unpack_float(const in vec4 rgba_value)
{
    const vec4 bit_shift = vec4(1.0/(256.0*256.0*256.0), 1.0/(256.0*256.0), 1.0/256.0, 1.0);
    float value = dot(rgba_value, bit_shift);
    return value;
}

void main(void) {
  // First time called, fill in distance transform
  // Last time called, move the label into RGB
  // Rest of the iterations, run the pde

  vec4 sourceColor = texture2D(sourceTextureSampler, varyingTextureCoordinate);
  vec4 phiRGBA = texture2D(intermediateTextureSampler, varyingTextureCoordinate);
  float phi = unpack_float(phiRGBA);
  vec4 outputColor;

  if (iteration == 0) {
    if ( length(varyingTextureCoordinate - seedPoint) < .03 ) {
      outputColor = pack_float( .999 );
    } else {
      outputColor = pack_float( 0. );
    }
  }

  if (iteration > 0 && iteration < numberOfIterations) {
    // calculate an iteration of delta phi

    #define S(point) unpack_float(texture2D(intermediateTextureSampler, varyingTextureCoordinate + point * sourceTexelSize));

    float sP0 = S(vec2(1., 0.));
    float s0P = S(vec2(0., 1.));
    float sN0 = S(vec2(-1., 0.));
    float s0N = S(vec2(0., -1.));

    #undef S

    vec2 gradient;
    // TODO upwind gradient: gradient = vec2( max(max(sP0-phi,phi-sN0),0.), max(max(s0P-phi,phi-s0N),0.) ) / sourceTexelSize;
    gradient = vec2( sP0-sN0, s0P-s0N ) / sourceTexelSize;

    float phiGradientMagnitude = length(gradient);

    #define S(point) texture2D(sourceTextureSampler, varyingTextureCoordinate + point * sourceTexelSize).r;

    sP0 = S(vec2(1., 0.));
    s0P = S(vec2(0., 1.));
    sN0 = S(vec2(-1., 0.));
    s0N = S(vec2(0., -1.));

    #undef S

    // TODO: rescale gradient:
    gradient = vec2( sP0-sN0, s0P-s0N ) / (2. * sourceTexelSize);
    //gradient = vec2( sP0-sN0, s0P-s0N );

    float sourceGradientMagnitude = length(gradient);

    float deltaT = .001;

    float phiValue;
    phiValue = phi + deltaT * phiGradientMagnitude * (1. / (1. + edgeWeight * sourceGradientMagnitude));

    phiValue = clamp(phiValue, 0., .9999);
    outputColor = pack_float(phiValue);
  }

  if (iteration == numberOfIterations) {
    if (phi > .001 && phi < 0.1) {
      outputColor = sourceColor + vec4(.4, .4, -.2, 1.0);
    } else {
      outputColor = sourceColor;
    }
    if ( length(varyingTextureCoordinate - seedPoint) < .01 ) {
      outputColor += vec4(-.4, -.4, .6, 1.);
    }
  }

  gl_FragColor = outputColor;
}

</script-->

<p>
    This demo uses WebGL.  Not all devices and browsers are supported.
</p>
<script src = "main.js"></script>
</body>
</html>
